// ABOUTME: Principal entity and store methods for identity management
// ABOUTME: Principals are the cryptographic identities (client, agent, pack) in the fold system

package store

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"
)

// Principal errors
var (
	ErrPrincipalNotFound = errors.New("principal not found")
	ErrDuplicatePubkey   = errors.New("duplicate pubkey fingerprint")
	ErrInvalidStatus     = errors.New("invalid principal status")
	ErrMetadataTooLarge  = errors.New("metadata exceeds 64KB limit")
)

// MaxMetadataSize is the maximum allowed size for metadata JSON (64KB)
const MaxMetadataSize = 64 * 1024

// PrincipalType represents the type of principal
type PrincipalType string

const (
	PrincipalTypeClient PrincipalType = "client"
	PrincipalTypeAgent  PrincipalType = "agent"
	PrincipalTypePack   PrincipalType = "pack"
)

// ValidPrincipalTypes lists all valid principal types
var ValidPrincipalTypes = []PrincipalType{
	PrincipalTypeClient,
	PrincipalTypeAgent,
	PrincipalTypePack,
}

// PrincipalStatus represents the status of a principal
type PrincipalStatus string

const (
	PrincipalStatusPending  PrincipalStatus = "pending"
	PrincipalStatusApproved PrincipalStatus = "approved"
	PrincipalStatusRevoked  PrincipalStatus = "revoked"
	PrincipalStatusOffline  PrincipalStatus = "offline"
	PrincipalStatusOnline   PrincipalStatus = "online"
)

// ValidPrincipalStatuses lists all valid principal statuses
var ValidPrincipalStatuses = []PrincipalStatus{
	PrincipalStatusPending,
	PrincipalStatusApproved,
	PrincipalStatusRevoked,
	PrincipalStatusOffline,
	PrincipalStatusOnline,
}

// Principal represents a cryptographic identity in the system
type Principal struct {
	ID          string          // UUID v4, generated by gateway
	Type        PrincipalType   // "client" | "agent" | "pack"
	PubkeyFP    string          // hex SHA-256 of public key (64 chars)
	DisplayName string          // human-readable name (1-100 chars)
	Status      PrincipalStatus // "pending" | "approved" | "revoked" | "offline" | "online"
	CreatedAt   time.Time       // when the principal was created
	LastSeen    *time.Time      // last activity timestamp (nil if never seen)
	Metadata    map[string]any  // arbitrary JSON metadata (max 64KB)
}

// PrincipalFilter specifies filtering options for listing principals
type PrincipalFilter struct {
	Type   *PrincipalType   // filter by type
	Status *PrincipalStatus // filter by status
	Limit  int              // max results (default 100, max 1000)
	Offset int              // pagination offset
}

// isValidStatus checks if the given status is valid
func isValidStatus(status PrincipalStatus) bool {
	for _, valid := range ValidPrincipalStatuses {
		if status == valid {
			return true
		}
	}
	return false
}

// CreatePrincipal creates a new principal in the database
func (s *SQLiteStore) CreatePrincipal(ctx context.Context, p *Principal) error {
	var metadataJSON *string
	if p.Metadata != nil {
		data, err := json.Marshal(p.Metadata)
		if err != nil {
			return fmt.Errorf("marshaling metadata: %w", err)
		}
		if len(data) > MaxMetadataSize {
			return ErrMetadataTooLarge
		}
		str := string(data)
		metadataJSON = &str
	}

	query := `
		INSERT INTO principals (principal_id, type, pubkey_fingerprint, display_name, status, created_at, last_seen, metadata_json)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`

	var lastSeenStr *string
	if p.LastSeen != nil {
		s := p.LastSeen.UTC().Format(time.RFC3339)
		lastSeenStr = &s
	}

	_, err := s.db.ExecContext(ctx, query,
		p.ID,
		p.Type,
		p.PubkeyFP,
		p.DisplayName,
		p.Status,
		p.CreatedAt.UTC().Format(time.RFC3339),
		lastSeenStr,
		metadataJSON,
	)
	if err != nil {
		// Check for UNIQUE constraint violation on pubkey_fingerprint
		if isDuplicatePubkeyError(err) {
			return ErrDuplicatePubkey
		}
		return fmt.Errorf("inserting principal: %w", err)
	}

	s.logger.Debug("created principal", "id", p.ID, "type", p.Type)
	return nil
}

// GetPrincipal retrieves a principal by ID
func (s *SQLiteStore) GetPrincipal(ctx context.Context, id string) (*Principal, error) {
	query := `
		SELECT principal_id, type, pubkey_fingerprint, display_name, status, created_at, last_seen, metadata_json
		FROM principals
		WHERE principal_id = ?
	`

	return s.scanPrincipal(s.db.QueryRowContext(ctx, query, id))
}

// GetPrincipalByPubkey retrieves a principal by pubkey fingerprint
func (s *SQLiteStore) GetPrincipalByPubkey(ctx context.Context, fp string) (*Principal, error) {
	query := `
		SELECT principal_id, type, pubkey_fingerprint, display_name, status, created_at, last_seen, metadata_json
		FROM principals
		WHERE pubkey_fingerprint = ?
	`

	return s.scanPrincipal(s.db.QueryRowContext(ctx, query, fp))
}

// UpdatePrincipalStatus updates a principal's status
func (s *SQLiteStore) UpdatePrincipalStatus(ctx context.Context, id string, status PrincipalStatus) error {
	if !isValidStatus(status) {
		return ErrInvalidStatus
	}

	query := `UPDATE principals SET status = ? WHERE principal_id = ?`

	result, err := s.db.ExecContext(ctx, query, status, id)
	if err != nil {
		return fmt.Errorf("updating principal status: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("getting rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrPrincipalNotFound
	}

	s.logger.Debug("updated principal status", "id", id, "status", status)
	return nil
}

// UpdatePrincipalLastSeen updates a principal's last_seen timestamp
func (s *SQLiteStore) UpdatePrincipalLastSeen(ctx context.Context, id string, t time.Time) error {
	query := `UPDATE principals SET last_seen = ? WHERE principal_id = ?`

	result, err := s.db.ExecContext(ctx, query, t.UTC().Format(time.RFC3339), id)
	if err != nil {
		return fmt.Errorf("updating principal last_seen: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("getting rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrPrincipalNotFound
	}

	return nil
}

// DeletePrincipal removes a principal by ID. Returns ErrPrincipalNotFound if
// the principal does not exist. Note: associated roles in the roles table are
// not automatically deleted and should be removed separately if needed.
func (s *SQLiteStore) DeletePrincipal(ctx context.Context, id string) error {
	query := `DELETE FROM principals WHERE principal_id = ?`

	result, err := s.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("deleting principal: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("getting rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrPrincipalNotFound
	}

	s.logger.Debug("deleted principal", "id", id)
	return nil
}

// ListPrincipals returns principals matching the filter criteria
func (s *SQLiteStore) ListPrincipals(ctx context.Context, f PrincipalFilter) ([]Principal, error) {
	// Apply defaults
	limit := f.Limit
	if limit <= 0 {
		limit = 100
	}
	if limit > 1000 {
		limit = 1000
	}

	query := `
		SELECT principal_id, type, pubkey_fingerprint, display_name, status, created_at, last_seen, metadata_json
		FROM principals
		WHERE (? IS NULL OR type = ?)
		  AND (? IS NULL OR status = ?)
		ORDER BY created_at DESC
		LIMIT ? OFFSET ?
	`

	var typeFilter, statusFilter *string
	if f.Type != nil {
		t := string(*f.Type)
		typeFilter = &t
	}
	if f.Status != nil {
		st := string(*f.Status)
		statusFilter = &st
	}

	rows, err := s.db.QueryContext(ctx, query,
		typeFilter, typeFilter,
		statusFilter, statusFilter,
		limit, f.Offset,
	)
	if err != nil {
		return nil, fmt.Errorf("querying principals: %w", err)
	}
	defer rows.Close()

	var principals []Principal
	for rows.Next() {
		p, err := s.scanPrincipalRow(rows)
		if err != nil {
			return nil, err
		}
		principals = append(principals, *p)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("iterating principal rows: %w", err)
	}

	return principals, nil
}

// CountPrincipals returns the count of principals matching the filter criteria
func (s *SQLiteStore) CountPrincipals(ctx context.Context, f PrincipalFilter) (int, error) {
	query := `
		SELECT COUNT(*)
		FROM principals
		WHERE (? IS NULL OR type = ?)
		  AND (? IS NULL OR status = ?)
	`

	var typeFilter, statusFilter *string
	if f.Type != nil {
		t := string(*f.Type)
		typeFilter = &t
	}
	if f.Status != nil {
		st := string(*f.Status)
		statusFilter = &st
	}

	var count int
	err := s.db.QueryRowContext(ctx, query,
		typeFilter, typeFilter,
		statusFilter, statusFilter,
	).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("counting principals: %w", err)
	}

	return count, nil
}

// scanPrincipal scans a single principal row from a sql.Row
func (s *SQLiteStore) scanPrincipal(row *sql.Row) (*Principal, error) {
	var p Principal
	var typeStr, statusStr string
	var createdAtStr string
	var lastSeenStr, metadataJSON *string

	err := row.Scan(
		&p.ID,
		&typeStr,
		&p.PubkeyFP,
		&p.DisplayName,
		&statusStr,
		&createdAtStr,
		&lastSeenStr,
		&metadataJSON,
	)

	if err == sql.ErrNoRows {
		return nil, ErrPrincipalNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("scanning principal: %w", err)
	}

	p.Type = PrincipalType(typeStr)
	p.Status = PrincipalStatus(statusStr)

	p.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
	if err != nil {
		return nil, fmt.Errorf("parsing created_at: %w", err)
	}

	if lastSeenStr != nil {
		t, err := time.Parse(time.RFC3339, *lastSeenStr)
		if err != nil {
			return nil, fmt.Errorf("parsing last_seen: %w", err)
		}
		p.LastSeen = &t
	}

	if metadataJSON != nil {
		if err := json.Unmarshal([]byte(*metadataJSON), &p.Metadata); err != nil {
			return nil, fmt.Errorf("unmarshaling metadata: %w", err)
		}
	}

	return &p, nil
}

// scanPrincipalRow scans a principal from sql.Rows (for list queries)
func (s *SQLiteStore) scanPrincipalRow(rows *sql.Rows) (*Principal, error) {
	var p Principal
	var typeStr, statusStr string
	var createdAtStr string
	var lastSeenStr, metadataJSON *string

	err := rows.Scan(
		&p.ID,
		&typeStr,
		&p.PubkeyFP,
		&p.DisplayName,
		&statusStr,
		&createdAtStr,
		&lastSeenStr,
		&metadataJSON,
	)
	if err != nil {
		return nil, fmt.Errorf("scanning principal row: %w", err)
	}

	p.Type = PrincipalType(typeStr)
	p.Status = PrincipalStatus(statusStr)

	p.CreatedAt, err = time.Parse(time.RFC3339, createdAtStr)
	if err != nil {
		return nil, fmt.Errorf("parsing created_at: %w", err)
	}

	if lastSeenStr != nil {
		t, err := time.Parse(time.RFC3339, *lastSeenStr)
		if err != nil {
			return nil, fmt.Errorf("parsing last_seen: %w", err)
		}
		p.LastSeen = &t
	}

	if metadataJSON != nil {
		if err := json.Unmarshal([]byte(*metadataJSON), &p.Metadata); err != nil {
			return nil, fmt.Errorf("unmarshaling metadata: %w", err)
		}
	}

	return &p, nil
}

// isDuplicatePubkeyError checks if the error is a unique constraint violation for pubkey
func isDuplicatePubkeyError(err error) bool {
	if err == nil {
		return false
	}
	errStr := err.Error()
	return strings.Contains(errStr, "UNIQUE constraint failed") &&
		strings.Contains(errStr, "pubkey_fingerprint")
}
