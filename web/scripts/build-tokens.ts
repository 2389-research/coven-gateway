/**
 * Reads tokens.json and generates:
 *   1. variables.css — CSS custom properties for all tokens
 *   2. theme.css — Tailwind v4 @theme block mapping semantic colors to utilities
 *
 * Color tokens use a --cg-* prefix to avoid namespace collision with Tailwind v4's
 * @theme --color-* namespace. The @theme block defines --color-* vars that reference
 * --cg-* vars, enabling utilities like `bg-accent` instead of `bg-[hsl(var(--color-accent))]`.
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { resolve, dirname } from 'path';

const TOKENS_PATH = resolve(import.meta.dirname!, '..', 'tokens', 'tokens.json');
const OUTPUT_DIR = resolve(import.meta.dirname!, '..', 'src', 'styles', 'generated');
const VARIABLES_PATH = resolve(OUTPUT_DIR, 'variables.css');
const THEME_PATH = resolve(OUTPUT_DIR, 'theme.css');

// Read and parse tokens
const tokens = JSON.parse(readFileSync(TOKENS_PATH, 'utf-8'));

// Flatten a nested object into path→value pairs: { "a.b.c": "value" }
function flatten(obj: unknown, prefix = ''): Record<string, string> {
  const result: Record<string, string> = {};
  if (typeof obj !== 'object' || obj === null) return result;
  for (const [key, value] of Object.entries(obj)) {
    const path = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'object' && value !== null) {
      Object.assign(result, flatten(value, path));
    } else {
      result[path] = String(value);
    }
  }
  return result;
}

// Resolve {path.to.value} references against a flat lookup.
// Tracks visited refs to prevent infinite recursion on cyclic references.
function resolveRefs(value: string, lookup: Record<string, string>, visited = new Set<string>()): string {
  return value.replace(/\{([^}]+)\}/g, (_, ref: string) => {
    if (visited.has(ref)) {
      console.warn(`Cyclic token reference detected: {${ref}}`);
      return `{${ref}}`;
    }
    const resolved = lookup[ref];
    if (resolved === undefined) {
      console.warn(`Unresolved token reference: {${ref}}`);
      return `{${ref}}`;
    }
    // Recursively resolve in case of chained references
    const next = new Set(visited);
    next.add(ref);
    return resolveRefs(resolved, lookup, next);
  });
}

// Convert a flat key to CSS var name.
// Color tokens get --cg-* prefix; non-color tokens get --{category}-* prefix.
function toCssVar(flatKey: string): string {
  if (flatKey.startsWith('color.')) {
    return '--cg-' + flatKey.slice('color.'.length).replace(/\./g, '-');
  }
  return '--' + flatKey.replace(/\./g, '-');
}

// Check if a resolved value looks like HSL channels (e.g., "226 76% 50%")
function isHslChannels(value: string): boolean {
  return /^\d+\s+\d+%\s+\d+%$/.test(value);
}

// Wrap HSL channel values in hsl() for valid CSS colors
function wrapHsl(value: string): string {
  return isHslChannels(value) ? `hsl(${value})` : value;
}

// Build the full flat lookup for reference resolution
const allFlat = flatten(tokens);

// Resolve all references
const resolved: Record<string, string> = {};
for (const [key, value] of Object.entries(allFlat)) {
  resolved[key] = resolveRefs(value, allFlat);
}

// Group tokens for output
function collectVars(prefix: string, exclude?: string[]): [string, string][] {
  return Object.entries(resolved)
    .filter(([k]) => k.startsWith(prefix))
    .filter(([k]) => !exclude?.some((ex) => k.startsWith(ex)))
    .map(([k, v]) => [toCssVar(k), v]);
}

// ─── Generate variables.css ────────────────────────────────────────────
let css = '/* Generated by build-tokens.ts — DO NOT EDIT */\n\n';

// :root block — everything except dark semantic colors
css += ':root {\n';

// Color primitives (--cg-primitives-*)
const primitives = collectVars('color.primitives.');
for (const [varName, value] of primitives) {
  css += `  ${varName}: ${wrapHsl(value)};\n`;
}

// Semantic colors — light theme as default (--cg-*)
css += '\n  /* Semantic colors (light) */\n';
const lightSemantic = collectVars('color.semantic.light.');
for (const [varName, value] of lightSemantic) {
  // Remap: --cg-semantic-light-bg → --cg-bg
  const shortVar = varName.replace('-semantic-light-', '-');
  css += `  ${shortVar}: ${wrapHsl(value)};\n`;
}

// Typography
css += '\n  /* Typography */\n';
const typo = collectVars('typography.');
for (const [varName, value] of typo) {
  css += `  ${varName}: ${value};\n`;
}

// Spacing
css += '\n  /* Spacing */\n';
const spacing = collectVars('spacing.');
for (const [varName, value] of spacing) {
  css += `  ${varName}: ${value};\n`;
}

// Sizing
css += '\n  /* Sizing */\n';
const sizing = collectVars('sizing.');
for (const [varName, value] of sizing) {
  css += `  ${varName}: ${value};\n`;
}

// Border radius
css += '\n  /* Border radius */\n';
const radius = collectVars('border.radius.');
for (const [varName, value] of radius) {
  css += `  ${varName}: ${value};\n`;
}

// Shadows
css += '\n  /* Shadows */\n';
const shadows = collectVars('shadow.');
for (const [varName, value] of shadows) {
  css += `  ${varName}: ${value};\n`;
}

// Motion
css += '\n  /* Motion */\n';
const motion = collectVars('motion.');
for (const [varName, value] of motion) {
  css += `  ${varName}: ${value};\n`;
}

// Z-index
css += '\n  /* Z-index */\n';
const zIndex = collectVars('zIndex.');
for (const [varName, value] of zIndex) {
  css += `  ${varName}: ${value};\n`;
}

css += '}\n';

// Dark theme overrides
css += '\n[data-theme="dark"] {\n';
const darkSemantic = collectVars('color.semantic.dark.');
for (const [varName, value] of darkSemantic) {
  const shortVar = varName.replace('-semantic-dark-', '-');
  css += `  ${shortVar}: ${wrapHsl(value)};\n`;
}
css += '}\n';

// ─── Generate theme.css (Tailwind v4 @theme block) ────────────────────
let theme = '/* Generated by build-tokens.ts — DO NOT EDIT */\n\n';
theme += '@theme {\n';

// Map semantic color tokens to Tailwind --color-* namespace.
// @theme creates CSS custom properties AND generates utility classes:
//   --color-accent → bg-accent, text-accent, border-accent, etc.
for (const [varName] of lightSemantic) {
  // --cg-semantic-light-bg → semantic var --cg-bg, Tailwind var --color-bg
  const cgVar = varName.replace('-semantic-light-', '-');
  const twVar = cgVar.replace('--cg-', '--color-');
  theme += `  ${twVar}: var(${cgVar});\n`;
}

// Font family — override Tailwind defaults with our token-defined stack
theme += '\n  --font-family-sans: var(--typography-fontFamily-sans);\n';
theme += '  --font-family-serif: var(--typography-fontFamily-serif);\n';
theme += '  --font-family-mono: var(--typography-fontFamily-mono);\n';

theme += '}\n';

// ─── Write output ──────────────────────────────────────────────────────
mkdirSync(dirname(VARIABLES_PATH), { recursive: true });
writeFileSync(VARIABLES_PATH, css, 'utf-8');
writeFileSync(THEME_PATH, theme, 'utf-8');
console.log(`Generated ${VARIABLES_PATH}`);
console.log(`Generated ${THEME_PATH}`);
