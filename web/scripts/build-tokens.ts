/**
 * Reads tokens.json and generates variables.css with CSS custom properties.
 * Phase 1: variables.css only. Tailwind theme extension deferred to Phase 2.
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { resolve, dirname } from 'path';

const TOKENS_PATH = resolve(import.meta.dirname!, '..', 'tokens', 'tokens.json');
const OUTPUT_DIR = resolve(import.meta.dirname!, '..', 'src', 'styles', 'generated');
const OUTPUT_PATH = resolve(OUTPUT_DIR, 'variables.css');

// Read and parse tokens
const tokens = JSON.parse(readFileSync(TOKENS_PATH, 'utf-8'));

// Flatten a nested object into path→value pairs: { "a.b.c": "value" }
function flatten(obj: unknown, prefix = ''): Record<string, string> {
  const result: Record<string, string> = {};
  if (typeof obj !== 'object' || obj === null) return result;
  for (const [key, value] of Object.entries(obj)) {
    const path = prefix ? `${prefix}.${key}` : key;
    if (typeof value === 'object' && value !== null) {
      Object.assign(result, flatten(value, path));
    } else {
      result[path] = String(value);
    }
  }
  return result;
}

// Resolve {path.to.value} references against a flat lookup.
// Tracks visited refs to prevent infinite recursion on cyclic references.
function resolveRefs(value: string, lookup: Record<string, string>, visited = new Set<string>()): string {
  return value.replace(/\{([^}]+)\}/g, (_, ref: string) => {
    if (visited.has(ref)) {
      console.warn(`Cyclic token reference detected: {${ref}}`);
      return `{${ref}}`;
    }
    const resolved = lookup[ref];
    if (resolved === undefined) {
      console.warn(`Unresolved token reference: {${ref}}`);
      return `{${ref}}`;
    }
    // Recursively resolve in case of chained references
    const next = new Set(visited);
    next.add(ref);
    return resolveRefs(resolved, lookup, next);
  });
}

// Convert a flat key like "color.primitives.neutral.500" to CSS var name "--color-neutral-500"
function toCssVar(flatKey: string): string {
  return '--' + flatKey.replace(/\./g, '-');
}

// Build the full flat lookup for reference resolution
const allFlat = flatten(tokens);

// Resolve all references
const resolved: Record<string, string> = {};
for (const [key, value] of Object.entries(allFlat)) {
  resolved[key] = resolveRefs(value, allFlat);
}

// Group tokens for output
function collectVars(prefix: string, exclude?: string[]): [string, string][] {
  return Object.entries(resolved)
    .filter(([k]) => k.startsWith(prefix))
    .filter(([k]) => !exclude?.some((ex) => k.startsWith(ex)))
    .map(([k, v]) => [toCssVar(k), v]);
}

// Build CSS output
let css = '/* Generated by build-tokens.ts — DO NOT EDIT */\n\n';

// :root block — everything except dark semantic colors
css += ':root {\n';

// Color primitives
const primitives = collectVars('color.primitives.');
for (const [varName, value] of primitives) {
  css += `  ${varName}: ${value};\n`;
}

// Semantic colors (light theme as default)
css += '\n  /* Semantic colors (light) */\n';
const lightSemantic = collectVars('color.semantic.light.');
for (const [varName, value] of lightSemantic) {
  // Remap: --color-semantic-light-bg → --color-bg
  const shortVar = varName.replace('-semantic-light-', '-');
  css += `  ${shortVar}: ${value};\n`;
}

// Typography
css += '\n  /* Typography */\n';
const typo = collectVars('typography.');
for (const [varName, value] of typo) {
  css += `  ${varName}: ${value};\n`;
}

// Spacing
css += '\n  /* Spacing */\n';
const spacing = collectVars('spacing.');
for (const [varName, value] of spacing) {
  css += `  ${varName}: ${value};\n`;
}

// Sizing
css += '\n  /* Sizing */\n';
const sizing = collectVars('sizing.');
for (const [varName, value] of sizing) {
  css += `  ${varName}: ${value};\n`;
}

// Border radius
css += '\n  /* Border radius */\n';
const radius = collectVars('border.radius.');
for (const [varName, value] of radius) {
  css += `  ${varName}: ${value};\n`;
}

// Shadows
css += '\n  /* Shadows */\n';
const shadows = collectVars('shadow.');
for (const [varName, value] of shadows) {
  css += `  ${varName}: ${value};\n`;
}

// Motion
css += '\n  /* Motion */\n';
const motion = collectVars('motion.');
for (const [varName, value] of motion) {
  css += `  ${varName}: ${value};\n`;
}

// Z-index
css += '\n  /* Z-index */\n';
const zIndex = collectVars('zIndex.');
for (const [varName, value] of zIndex) {
  css += `  ${varName}: ${value};\n`;
}

css += '}\n';

// Dark theme overrides
css += '\n[data-theme="dark"] {\n';
const darkSemantic = collectVars('color.semantic.dark.');
for (const [varName, value] of darkSemantic) {
  const shortVar = varName.replace('-semantic-dark-', '-');
  css += `  ${shortVar}: ${value};\n`;
}
css += '}\n';

// Write output
mkdirSync(dirname(OUTPUT_PATH), { recursive: true });
writeFileSync(OUTPUT_PATH, css, 'utf-8');
console.log(`Generated ${OUTPUT_PATH}`);
