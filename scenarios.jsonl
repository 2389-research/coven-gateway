{"name": "agent-identity-disabled-mode", "description": "Unknown SSH keys are rejected when auto-registration is disabled (default)", "given": "Gateway running with agent_auto_registration unset or 'disabled', fresh database", "when": "Agent connects with SSH key not in principals table", "then": "Connection rejected with 'unknown public key' error", "validates": ["secure default behavior", "SSH auth flow", "principal lookup"]}
{"name": "agent-identity-approved-mode", "description": "Unknown SSH keys are auto-registered and connected when mode is 'approved'", "given": "Gateway running with agent_auto_registration='approved', fresh database", "when": "Agent connects with SSH key not in principals table", "then": "Principal auto-created with 'approved' status, agent connects successfully, receives 12-char instance ID", "validates": ["auto-registration flow", "principal creation", "instance ID generation", "display name format"]}
{"name": "agent-identity-pending-mode", "description": "Unknown SSH keys are auto-registered with pending status when mode is 'pending'", "given": "Gateway running with agent_auto_registration='pending', fresh database", "when": "Agent connects with SSH key not in principals table", "then": "Principal auto-created with 'pending' status, connection rejected with 'admin approval required' message", "validates": ["pending mode flow", "principal status", "error messaging"]}
{"name": "bind-via-instance-id", "description": "Bind channel to agent using instance ID, verify binding, delete binding", "given": "Gateway running with agent_auto_registration='approved', agent online with instance_id", "when": "POST /api/bindings with instance_id, GET /api/bindings, DELETE /api/bindings", "then": "Binding created with principal_id + working_dir, binding queryable by frontend+channel_id, binding removed on DELETE with 404 after", "validates": ["instance lookup", "binding creation", "binding query", "binding deletion", "idempotent rebind"]}
{"name": "binding-offline-agent-status", "description": "Binding correctly reports agent online/offline status", "given": "Gateway running, binding exists for agent", "when": "Agent connects then disconnects, GET /api/bindings queries status", "then": "online=true while connected, online=false after disconnect, list shows agent_online accurately", "validates": ["GetByPrincipalAndWorkDir lookup", "online status tracking", "binding status endpoint", "binding list endpoint"]}
{"name": "binding-api-validation", "description": "Binding API validates required parameters", "given": "Gateway running with authenticated client", "when": "POST /api/bindings with missing frontend/channel_id/instance_id", "then": "Returns 400 Bad Request with appropriate error message for each missing field", "validates": ["input validation", "error responses", "API contract"]}
{"name": "binding-idempotent-rebind", "description": "Rebinding same agent to same channel is idempotent", "given": "Gateway running, binding exists for channelâ†’agent", "when": "POST /api/bindings with same frontend/channel_id/instance_id", "then": "Returns 200 OK (not 201), binding_id unchanged, rebound_from is null", "validates": ["idempotent rebind", "HTTP status codes", "rebound tracking"]}
{"name": "gateway-health", "description": "Gateway starts successfully and health endpoints respond correctly", "given": "Gateway binary built, valid config with database and ports", "when": "Start gateway, query /health and /health/ready endpoints", "then": "/health returns 200, /health/ready returns 503 (no agents), database file created", "validates": ["gateway startup", "HTTP server", "health endpoints", "database initialization"]}
{"name": "agent-registration", "description": "Agent connects via gRPC and completes registration handshake", "given": "Gateway running with auth disabled", "when": "Agent opens AgentStream, sends RegisterAgent with ID/name/capabilities", "then": "Gateway responds with Welcome containing server_id and confirmed agent_id", "validates": ["gRPC connectivity", "agent registration", "Welcome response", "agent ID confirmation"]}
{"name": "message-flow-e2e", "description": "Message flows from HTTP client through gateway to agent and back via SSE", "given": "Gateway running, agent registered and handling messages", "when": "HTTP POST /api/send with agent_id/content/sender", "then": "SSE stream includes thinking, text chunks, and done events; agent receives SendMessage and responds", "validates": ["HTTP API", "SSE streaming", "message routing", "agent message handling", "request/response correlation"]}
{"name": "pack-tool-registration", "description": "Pack registers tools via gRPC and agent receives tool definitions on connect", "given": "Gateway running with auth disabled", "when": "Pack calls PackService.Register with manifest, then agent connects", "then": "Pack stream opened, agent Welcome includes available_tools matching pack manifest", "validates": ["pack registration", "tool manifest processing", "tool distribution to agents"]}
{"name": "pack-tool-execution", "description": "Agent requests pack tool execution and receives result through gateway", "given": "Gateway running, pack registered with tools, agent connected", "when": "Agent sends ExecutePackTool request", "then": "Pack receives ExecuteToolRequest, sends ToolResult, agent receives PackToolResult with output", "validates": ["tool execution routing", "pack-to-agent flow", "result correlation"]}
{"name": "full-integration", "description": "Complete flow: HTTP client -> gateway -> agent with pack tool usage -> SSE response", "given": "Gateway running, pack with get_time tool, agent registered", "when": "HTTP POST with message that triggers tool usage", "then": "SSE response includes thinking, tool_use, text, and done events; agent executed pack tool during processing", "validates": ["end-to-end integration", "all components working together", "pack tools in message flow"]}
